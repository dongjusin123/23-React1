# 202130310 신동주
# 7주차 (2023.04.16)

훅

- 리액트의 state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 것

- useState()

  1.  state를 사용하기 위한 훅
  2.  함수 컴포넌트에서는 기본적으로 state라는 것을 제공하지 않음
  3.  클래스 컴포넌트처럼 state를 사용하고 싶으면 useState() 훅을 사용해야함

- 사용법

  1.  const [변수명, set함수명] = useState (초깃값);
  2.  변수 각각에 대해 set 함수가 따로 존재함

- useEffect()

  1.  사이드 이펙트를 수행하기 위한 훅
  2.  사이드 이펙트란 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 등의 작업
  3.  useEffect() 훅만으로 클래스 컴포넌트의 생명주기 함수들과 동일한 기능을 수행할 수 있음

- 사용법

  1.  useEffect(이펙트 함수, 의존성 배열);
  2.  의존성 배열 안에 있는 변수 중에 하나라도 값이 변경되었을 때 이펙트 함수가 실행됨
  3.  의존성 배열에 빈 배열([])을 넣으면 언마운트시에 단 한 번씩만 실행됨
  4.  의존성 배열 생략 시 컴포넌트가 업데이트될 때마다 호출됨
  5.  선언된 컴포넌트의 props와 state에 접근할 수 있음
  6.  useEffect()에서 리턴하는 함수는 컴포넌트 마운트가 해제될 때 호출됨

- useMemo()

  1.  Memoized value를 리턴하는 훅
  2.  연산량이 높은 작업이 매번 렌더링될 때마다 반복되는 것을 피하기 위해 사용
  3.  렌더링이 일어나는 동안 실행되므로 렌더링이 일어나는 동안 실행돼서는 안될 작업을 useMemo()에 넣으면 안 됨

- 사용법

  1.  const memoizedValue = useMemo(값 생성 함수, 의존성 배열);
  2.  의존성 배열에 들어있는 변수가 변했을 경우에만 새로 값 생성 함수를 호출하여 결괏값을 반환함
  3.  그렇지 않은 경우에는 기존 함수의 결괏값을 그대로 반환함
  4.  의존성 배열을 넣지 않을 경우 렌더링이 일어날 때마다 매번 값 생성 함수가 실행되므로 의미가 없음

- useCallback()

  1.  useMemo() 훅과 유사하지만 값이 아닌 함수를 반환한다는 점이 다름
  2.  useCallback(콜백 함수, 의존성 배열);은 useMemo(() => 콜백 함수, 의존성 배열);과 동일 훅을 사용하여 불필요한 함수 재정의 작업을 없애는 것

- 사용법

  1.  const memoizedCallback = useCallback(콜백 함수, 의존성 배열);
  2.  의존성 배열에 들어있는 변수가 변했을 경우에만 콜백 함수를 다시 정의해서 리턴함.

- useRef()

  1.  레퍼런스를 사용하기 위한 훅
  2.  레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미
  3.  매번 렌더링될 때마다 항상 같은 레퍼런스 객체를 반환

- 사용법

  1.  const refContainer = useRef(초깃값);
  2.  current라는 속성을 통해서 접근

- 훅의 규칙

  1.  무조건 최상위 레벨에서만 호출해야함
  2.  반복문이나 조건문 또는 중첩된 함수들 안에서 훅을 호출하면 안 됨
  3.  컴포넌트가 렌더링될 때마다 매번 같은 순서로 호출되어야 함
  4.  리액트 함수 컴포넌트에서만 훅을 호출해야 함
  5.  혹은 리액트 함수 컴포넌트에서 호출하거나 직접 만든 커스텀 훅에서만 호출할 수 있음

- 커스텀 훅
  1.  이름이 use로 시작하고 내부에서 다른 훅을 호출하는 단순한 자바스크립트 함수
  2.  파라미터로 무엇을 받을지, 어떤 것을 리턴해야 할지를 개발자가 직접 정할 수 있음
  3.  중복되는 로직을 커스텀 훅으로 추출하여 재사용성을 높이기
  4.  이름이 use로 시작하지 않으면 특정 함수의 내부에서 훅을 호출하는지를 알 수 없기 때문에 훅의 규칙 위반 여부를 자동으로 확인할 수 없음
  
# 6주차 (2023 04 06)

컴포넌트 추출
  - 큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것
  - 기능 단위로 구분하는 것이 좋고, 나중에 곧바로 재사용이 가능한 형태로 추출하는 것이 좋음
 
State
  - State란?
     1. 리액트 컴포넌트의 변경 가능한 데이터
     2. 컴포넌트를 개발하는 개발자가 직접 정의해서 사용
     3.  atete 가 변경될 경우 컴포넌트가 재렌더링됨
     4.  렌더링이나 데이터 흐름에 사용되는 값만 state에 포함시켜야 함

  - State의 특징
     1. 자바스크립트 객체 형태로 존재
     2. 직접적인 변경이 불가능 함
     3. 클래스 컴포넌트
      3-1. 생성자에서 모든 state를 한번에 정의
      3-2. state를 변경하고자 할 때에는 꼭 set State()함수를 사용해야 함
     4. 함수 컴포넌트
      4-1. useState()훅을 사용하여 각각의 state를 정의
      4-2. 각 state별로 주어지는 set함수를 사용하여 state 값을 변경

생명주기
   - 마운트
     1. 컴포넌트가 생성될 떼
     2. componentDidMount()

   - 업데이트
     1. 컴포넌트의 props가 변경될 때
     2. setState() 함수 호출에 의해 state가 변경될 때
     3. forceUpdate()라는 강제 업데이트 함수가 호출될 때
     4. componentDidUpdate()
   
   -  언마운트
     1. 상위 컴포넌트에서 현재 컴포넌트를 더 이상 화면에 표시하지 않게 될 때
     2. componentWillUnmount()
   
   - 컴포넌트는 계속 존재하는 것이 아니라 시간의 흐름에 따라 생성되고 업데이트되다가 사라지는 과정을 겪음
    


# 5주차 (2023 03 30)

리액트 컴포넌트
- 컴포넌트 기반 구조
   1. 작은 컴포넌트들이 모여서 하나의 컴포넌트를 구성하고 이러한 컴포넌트들이 모여서 전체 페이지를 구성
- 개념적으로는 자바스크립트의 함수와 비슷함
   1. 속성들을 입력으로 받아서 그에 맞는 리액트 엘리먼트를 생성하여 리턴함

Props
 - Props의 개념
   1. 리액트 컴포넌트의 속성
   2. 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체
   
 - Props의 특징
   1. 읽기 전용
   2. 리액트 컴포넌트의 props는 바꿀 수 없고, 같은 props가 들어오면 항상 같은 엘리먼트를 리턴해야 함
   
 - Props 사용법
   1. JSX를 사용할 경우 컴포넌트에 키-값 쌍 형태로 넣어 주면 됨
   2. 문자열 이외에 정수,변수,그리고 다른 컴포넌트 등이 들어갈 경우에는 중괄호를 사용해서 감싸주어야 함
   3. JSX를 사용하지 않는 경우에는 createElement() 함수의 두 번째 파라미터로 자바스크립트 객체를 넣어 주면 됨

엘리먼트에 대해 배웠다
- 엘리먼트
   엘리먼트의 정의
   1. 리액트 앱의 가장 작은 빌딩 블록들
   2. 화면에 나타나는 내용을 기술하는 자바스크립트 객체
   3. 리액트 엘리먼트는 DOM 엘리먼트의 가상 표현

  엘리먼트의 생김새
   1. 엘리먼트는 자바스크립트 객체 형태로 존재
   2. 컴포넌트 유형과 속성 및 내부의 모든 자식에 대한 정보를 포함하고 있는 일반적인 자바스크립트 객체

  엘리먼트의 특징
   1. 불변성을 갖고 있음
   2. 엘리먼트 생성 후에는 자식이나 속성을 바꿀 수 없음

- 엘리먼트 렌더링하기
   렌더링을 위해 ReactDom의 render()라는 함수를 사용
    1. 리액트 엘리먼트를 HTML 엘리먼트에 렌더링하는 역할
   렌더링 되는 과정은 Victual DOM에서 실제 DOM으로 이동하는 과정
- 렌더링된 엘리먼트 업데이트하기
    엘리먼트는 한 번 생성되면 바꿀 수 없기 때문에 엘리먼트를 업데이트하기 위해서는 다시 생성해야 함
    기존 엘리먼트를 변경하는 것이 아니라 새로운 엘리먼트를 생성해서 바꿔치기하는 것


# 4주차 (2023 03 23)

git hub에 리액트를 직접 연결했다.
기존  respository를 삭제하고 새로운 respository를 생성했다.

JSX는 자바스크립트와 XML/HTML을 함께 사용할 수 있는 자바스크립트의 확장 문법이다.

JSX의 역할은 2가지가 있는데 첫번째는 JSX로 작성된 코드를 자바스크립트 코드로 변환하는 역할과 두번째는 리액트가 JSX코드를 모드 createElement() 함수를 사용하는 코드로 변환시키는 역할을 한다.

JSX의 장점
   1. 코드가 간결해진다.
   2. 가독성이 좋아진다.
   3. Injection Attack을 방어함으로써 보안성이 올라갔다. 

JSX 사용법
   1. 기본적으로 모든 자바스크립트 문법을 지원
   2. 자바스크립트에 XML과 HTML을 섞어서 사용한다
   3. 중괄호를 사용하여 자바스크립트 코드를 삽입한다. 

# 3주차 (2023.03.16)

Node.js를 설치했다,그리고 버전을 확인했다.

리액트는 사용자와 웹사이트의 상호작용을 돕는 인터페이스를 만들기 위한 자바스크립트 기능 모음집이다.

리액트의 장점
 1. 빠른 업데이트와 렌더링 속도
 2. 컴포넌트 기반의 구조
 3. 높은 재사용성
 4. 몇 년 동안 지속될 영향력
 5. 활발한 지식 공유 $ 커뮤니티
 6. 모바일 앱 개발 가능

리액트의 단점
 1. 방대한 학습량
 2. 높은 상태 관리 복잡도

# 2주차 (2023.03.09)

깃 허브 계정을 만들고  23-React1라는 이름의 repository를 추가했다.

깃 허브는 다수가 동시에 사용할 수 있는 사이트이다.

깃 허브 주소를 복사하고 공유하는 사이트에 올렸다.

웹 기본 연결 브라우저를 인터넷 익스플로어에서 크롬으로 변경했다.

깃 이그노어는 깃 허브의 공유과정에서 생기는 문제를 방지해주기 위한 파일이다.


# 1주차 (2023.03.02)
> 오리엔테이션
> github 가입
