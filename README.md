# 202130310 신동주

# 12주차 (2023.05.25)

컴페스트란 

  - 컴포넌트들 사이에서 데이터를 props를 통해 전달하는 것이 아닌 컴포넌트 트리를 통해 곧바로 데이터를 전달하는 방식
  - 어떤 컴포넌트든지 컨텍스트에 있는 데이터에 쉽게 접근할 수 있음

컨텍스트 API

  - React.createContext()
    1. 컨텍스트를 생성하기 위한 함수
    2. 컨텍스트 객체를 리턴함
    3. 기본값으로 undefined를 넣으면 기본값이 사용되지 않음
  - 

# 11주차 (2023.05.18)

합성이란

  - 여러 개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것
  - 다양하고 복잡한 컴포넌트를 효율적으로 개발할 수 있음

합성 기법

  - Containment
  
    1. 하위 컴포넌트를 포함하는 형태의 합성 방법
    2. 리액트 컴포넌트의 props에 기본적으로 들어있는 children 속성을 사용
    3. 여러 개의 children 집합이 필요한 경우 별도로 props를 각각 정의해서 사용
   
  - Specialization
  
    1. 범용적인 개념을 구별되게 구체화하는 것
    2. 범용적으로 쓸 수 있는 컴포넌트를 만들어 놓고 이를 구체화시켜서 컴포넌트를 사용하는 합성 방법
   
  - Containmemt와 Specialization을 함께 사용하기
  
    1. props.children을 통해 하위 컴포넌트를 포함시키기(Containment)
    2. 별도의 props를 선언하여 구체화시키기(Specialization)
   
  상속
   - 다른 컴포넌트로부터 상속받아서 새로운 컴포넌트를 만드는 것
   - 상속을 사용하여 컴포넌트를 만드는 것을 추천할 만한 사용 사례를 찾지 못함
   - 리액트에서는 상속이라는 방법을 사용하는 것보다는 합성을 사용하는 것이 더 좋음

   


# 10주차 (2023.05.11)

시험 점수를 확인하고 나머진 자율 학습 시간을 가졌다

# 9주차 (2023.05.04)

리스트

  - 같은 아이템을 순서대로 모아놓은 것

키

  - 각 객체나 아이템을 구분할 수 있는 고유한 값

여러갱의 컴포넌트 렌더링

  - 자바스크립트 배열의 map() 함수를 사용
    
    1. 배열에 들어있는 각 변수에 어떤 처리를 한 뒤 결과(엘리먼트)를 배열로 만들어서 리턴함
    2. map() 함수 안에 있는 엘리먼트는 꼭 키가 필요함

리스트의 키

  - 리스트에서 아이템을 구분하기 위한 고유한 문자열
  - 리스트에서 어떤 아이템이 변경, 추가 또는 제거되었는지 구분하기 위해 사용
  - 리액트에서는 키의 값은 같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 됨

다양한 키값의 사용법
  
  - 숫자 값을 사용
    
    1. 배열에 중복된 숫자가 들어있다면 키값도 중복되기 때문에 고유해야 한다는 키값의 조건이 충족되지 않음
  
  - id를 사용
    
    1. id의 의미 자체가 고유한 값이므로 키값으로 사용하기 적합
    2. id가 ㅇ있는 경우에는 보통 id 값을 키값으로 사용

폼이란?

  - 사용자로부터 입력을 받기 위해 사용하는 양식

제어 컴포넌트

  - 사용자가 입력한 값에 접근하고 제어할 수 있게 해주는 컴포넌트
  - 값이 리액트의 통제를 받는 입력 폼 엘리먼트

<input type="test"> 태그

  - 한 줄로 텍스트를 입력받기 위한 HTML 태그
  - 리액트에서는 value라는 attribute로 입력된 값을 관리

<textarea> 태그

  - 여러 줄에 걸쳐서 텍스트를 입력받기 위한 HTML 태그
  - 리액트에서는 value라는 attribute로 입력된 값을 관리

<select> 태그

  - 드롭다운 목록을 보여주기 위한 HTML 태그
  - 여러 가지 옵션 중에서 하나 또는 여러 개를 선택할 수 있는 기능을 제공
  - 리액트에서는 value라는 attribute로 입력된 값을 관리

<input type="file"> 태그

  - 디바이스의 저장 장치로부터 사용자가 하나 또는 여러 개의 파일을 선택할 수 있게 해주는 HTML 태그
  - 서버로 파일을 업로드하거나 자바스크립트의 File API를 사용해서 파일을 다룰 때 사용
  - 읽기 전용이기 때문에 리액트에서는 비제어 컴포넌트가 됨

여러 개의 입력 다루기

  - 컴포넌트에서 여러 개의 state를 선언하여 각각의 입력에 대해 사용하면 됨

Input Null Value

  -value prop은 넣되 자유롭게 입력할 수 있게 만들고 싶을 경우, 값에 undefined 또는 null을 넣으면 됨
  
   

# 8주차 (2023.04.27)

이벤트

 - 사용자가 버튼을 클릭하는 등의 시간을 의미

이벤트 처리하기

 - DOM의 이벤트
    
    1. 이벤트의 이름을 모두 소문자로 표기
    2. 이벤트를 처리할 함수를 문자열로 전달

 - 리액트의 이벤트

    1. 이벤트의 이름을 카멜 표기법으로 표기
    2. 이벤트를 처리할 함수를 그대로 전달

 - 이벤트 핸들러

    1. 이벤트가 발생했을 때 해당 이벤트를 처리하는 함수
    2. 이벤트 리스너라고 부르기도 함
    3. 클래스 컴포넌트
      3-1 클래스의 함수로 정의하고 생성자에서 바인딩해서 사용
      3-2 클래스필드 문법도 사용가능

 - 함수 컴포넌트
   
    1. 함수 안에 함수로 정의하거나 arrow function을 사용해서 정의

Arguments 전달하기
 
 - Arguments란?
   
    1. 함수에 전달할 데이터
    2. 파라미터 또는 매개변수라고 부르기도 함

 - 클래스 컴포넌트
    1. arrow function을 사용하거나 Function.prototype.bind를 사용해서 전달
 - 함수 컴포넌트
    1. 이벤트 핸들러 호출 시 원하는 순서대로 매개변수를 넣어서 사용

조건부 랜딩

 - 조건에 따라 렌더링의 결과가 달라지도록 하는 것

엘리먼트 변수
 
 - 리액트 엘리먼트를 변수처럼 저장해서 사용하는 방법

인라인 조건
 
 - 조건문을 코드 안에 집어넣는 것
 - 인라인 if
    1. if-Else문을 필요한 곳에 직접 집어 넣어서 사용하는 방법
    2. 삼항 연산자 ?를 사용
    3. 앞에 나오는 조건문이 true면 첫 번째 항목을 리턴,false면 두 번째 항목을 리턴
    4. 조건에 따라 각기 다른 엘리먼트를 렌더링하고 싶을 때 사용

컴포넌트 렌더링 막기

 - 리액트에서는 null을 리턴하면 렌더링되지 않음
 - 특정 컴포넌트를 렌더링하고 싶지 않을 경우 null을 리턴하면 됨


# 7주차 (2023.04.16)

훅

- 리액트의 state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 것

- useState()

  1.  state를 사용하기 위한 훅
  2.  함수 컴포넌트에서는 기본적으로 state라는 것을 제공하지 않음
  3.  클래스 컴포넌트처럼 state를 사용하고 싶으면 useState() 훅을 사용해야함

- 사용법

  1.  const [변수명, set함수명] = useState (초깃값);
  2.  변수 각각에 대해 set 함수가 따로 존재함

- useEffect()

  1.  사이드 이펙트를 수행하기 위한 훅
  2.  사이드 이펙트란 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 등의 작업
  3.  useEffect() 훅만으로 클래스 컴포넌트의 생명주기 함수들과 동일한 기능을 수행할 수 있음

- 사용법

  1.  useEffect(이펙트 함수, 의존성 배열);
  2.  의존성 배열 안에 있는 변수 중에 하나라도 값이 변경되었을 때 이펙트 함수가 실행됨
  3.  의존성 배열에 빈 배열([])을 넣으면 언마운트시에 단 한 번씩만 실행됨
  4.  의존성 배열 생략 시 컴포넌트가 업데이트될 때마다 호출됨
  5.  선언된 컴포넌트의 props와 state에 접근할 수 있음
  6.  useEffect()에서 리턴하는 함수는 컴포넌트 마운트가 해제될 때 호출됨

- useMemo()

  1.  Memoized value를 리턴하는 훅
  2.  연산량이 높은 작업이 매번 렌더링될 때마다 반복되는 것을 피하기 위해 사용
  3.  렌더링이 일어나는 동안 실행되므로 렌더링이 일어나는 동안 실행돼서는 안될 작업을 useMemo()에 넣으면 안 됨

- 사용법

  1.  const memoizedValue = useMemo(값 생성 함수, 의존성 배열);
  2.  의존성 배열에 들어있는 변수가 변했을 경우에만 새로 값 생성 함수를 호출하여 결괏값을 반환함
  3.  그렇지 않은 경우에는 기존 함수의 결괏값을 그대로 반환함
  4.  의존성 배열을 넣지 않을 경우 렌더링이 일어날 때마다 매번 값 생성 함수가 실행되므로 의미가 없음

- useCallback()

  1.  useMemo() 훅과 유사하지만 값이 아닌 함수를 반환한다는 점이 다름
  2.  useCallback(콜백 함수, 의존성 배열);은 useMemo(() => 콜백 함수, 의존성 배열);과 동일 훅을 사용하여 불필요한 함수 재정의 작업을 없애는 것

- 사용법

  1.  const memoizedCallback = useCallback(콜백 함수, 의존성 배열);
  2.  의존성 배열에 들어있는 변수가 변했을 경우에만 콜백 함수를 다시 정의해서 리턴함.

- useRef()

  1.  레퍼런스를 사용하기 위한 훅
  2.  레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미
  3.  매번 렌더링될 때마다 항상 같은 레퍼런스 객체를 반환

- 사용법

  1.  const refContainer = useRef(초깃값);
  2.  current라는 속성을 통해서 접근

- 훅의 규칙

  1.  무조건 최상위 레벨에서만 호출해야함
  2.  반복문이나 조건문 또는 중첩된 함수들 안에서 훅을 호출하면 안 됨
  3.  컴포넌트가 렌더링될 때마다 매번 같은 순서로 호출되어야 함
  4.  리액트 함수 컴포넌트에서만 훅을 호출해야 함
  5.  혹은 리액트 함수 컴포넌트에서 호출하거나 직접 만든 커스텀 훅에서만 호출할 수 있음

- 커스텀 훅
  1.  이름이 use로 시작하고 내부에서 다른 훅을 호출하는 단순한 자바스크립트 함수
  2.  파라미터로 무엇을 받을지, 어떤 것을 리턴해야 할지를 개발자가 직접 정할 수 있음
  3.  중복되는 로직을 커스텀 훅으로 추출하여 재사용성을 높이기
  4.  이름이 use로 시작하지 않으면 특정 함수의 내부에서 훅을 호출하는지를 알 수 없기 때문에 훅의 규칙 위반 여부를 자동으로 확인할 수 없음
  
# 6주차 (2023 04 06)

컴포넌트 추출
  - 큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것
  - 기능 단위로 구분하는 것이 좋고, 나중에 곧바로 재사용이 가능한 형태로 추출하는 것이 좋음
 
State
  - State란?
     1. 리액트 컴포넌트의 변경 가능한 데이터
     2. 컴포넌트를 개발하는 개발자가 직접 정의해서 사용
     3.  atete 가 변경될 경우 컴포넌트가 재렌더링됨
     4.  렌더링이나 데이터 흐름에 사용되는 값만 state에 포함시켜야 함

  - State의 특징
     1. 자바스크립트 객체 형태로 존재
     2. 직접적인 변경이 불가능 함
     3. 클래스 컴포넌트
      3-1. 생성자에서 모든 state를 한번에 정의
      3-2. state를 변경하고자 할 때에는 꼭 set State()함수를 사용해야 함
     4. 함수 컴포넌트
      4-1. useState()훅을 사용하여 각각의 state를 정의
      4-2. 각 state별로 주어지는 set함수를 사용하여 state 값을 변경

생명주기
   - 마운트
     1. 컴포넌트가 생성될 떼
     2. componentDidMount()

   - 업데이트
     1. 컴포넌트의 props가 변경될 때
     2. setState() 함수 호출에 의해 state가 변경될 때
     3. forceUpdate()라는 강제 업데이트 함수가 호출될 때
     4. componentDidUpdate()
   
   -  언마운트
     1. 상위 컴포넌트에서 현재 컴포넌트를 더 이상 화면에 표시하지 않게 될 때
     2. componentWillUnmount()
   
   - 컴포넌트는 계속 존재하는 것이 아니라 시간의 흐름에 따라 생성되고 업데이트되다가 사라지는 과정을 겪음
    


# 5주차 (2023 03 30)

리액트 컴포넌트
- 컴포넌트 기반 구조
   1. 작은 컴포넌트들이 모여서 하나의 컴포넌트를 구성하고 이러한 컴포넌트들이 모여서 전체 페이지를 구성
- 개념적으로는 자바스크립트의 함수와 비슷함
   1. 속성들을 입력으로 받아서 그에 맞는 리액트 엘리먼트를 생성하여 리턴함

Props
 - Props의 개념
   1. 리액트 컴포넌트의 속성
   2. 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체
   
 - Props의 특징
   1. 읽기 전용
   2. 리액트 컴포넌트의 props는 바꿀 수 없고, 같은 props가 들어오면 항상 같은 엘리먼트를 리턴해야 함
   
 - Props 사용법
   1. JSX를 사용할 경우 컴포넌트에 키-값 쌍 형태로 넣어 주면 됨
   2. 문자열 이외에 정수,변수,그리고 다른 컴포넌트 등이 들어갈 경우에는 중괄호를 사용해서 감싸주어야 함
   3. JSX를 사용하지 않는 경우에는 createElement() 함수의 두 번째 파라미터로 자바스크립트 객체를 넣어 주면 됨

엘리먼트에 대해 배웠다
- 엘리먼트
   엘리먼트의 정의
   1. 리액트 앱의 가장 작은 빌딩 블록들
   2. 화면에 나타나는 내용을 기술하는 자바스크립트 객체
   3. 리액트 엘리먼트는 DOM 엘리먼트의 가상 표현

  엘리먼트의 생김새
   1. 엘리먼트는 자바스크립트 객체 형태로 존재
   2. 컴포넌트 유형과 속성 및 내부의 모든 자식에 대한 정보를 포함하고 있는 일반적인 자바스크립트 객체

  엘리먼트의 특징
   1. 불변성을 갖고 있음
   2. 엘리먼트 생성 후에는 자식이나 속성을 바꿀 수 없음

- 엘리먼트 렌더링하기
   렌더링을 위해 ReactDom의 render()라는 함수를 사용
    1. 리액트 엘리먼트를 HTML 엘리먼트에 렌더링하는 역할
   렌더링 되는 과정은 Victual DOM에서 실제 DOM으로 이동하는 과정
- 렌더링된 엘리먼트 업데이트하기
    엘리먼트는 한 번 생성되면 바꿀 수 없기 때문에 엘리먼트를 업데이트하기 위해서는 다시 생성해야 함
    기존 엘리먼트를 변경하는 것이 아니라 새로운 엘리먼트를 생성해서 바꿔치기하는 것


# 4주차 (2023 03 23)

git hub에 리액트를 직접 연결했다.
기존  respository를 삭제하고 새로운 respository를 생성했다.

JSX는 자바스크립트와 XML/HTML을 함께 사용할 수 있는 자바스크립트의 확장 문법이다.

JSX의 역할은 2가지가 있는데 첫번째는 JSX로 작성된 코드를 자바스크립트 코드로 변환하는 역할과 두번째는 리액트가 JSX코드를 모드 createElement() 함수를 사용하는 코드로 변환시키는 역할을 한다.

JSX의 장점
   1. 코드가 간결해진다.
   2. 가독성이 좋아진다.
   3. Injection Attack을 방어함으로써 보안성이 올라갔다. 

JSX 사용법
   1. 기본적으로 모든 자바스크립트 문법을 지원
   2. 자바스크립트에 XML과 HTML을 섞어서 사용한다
   3. 중괄호를 사용하여 자바스크립트 코드를 삽입한다. 

# 3주차 (2023.03.16)

Node.js를 설치했다,그리고 버전을 확인했다.

리액트는 사용자와 웹사이트의 상호작용을 돕는 인터페이스를 만들기 위한 자바스크립트 기능 모음집이다.

리액트의 장점
 1. 빠른 업데이트와 렌더링 속도
 2. 컴포넌트 기반의 구조
 3. 높은 재사용성
 4. 몇 년 동안 지속될 영향력
 5. 활발한 지식 공유 $ 커뮤니티
 6. 모바일 앱 개발 가능

리액트의 단점
 1. 방대한 학습량
 2. 높은 상태 관리 복잡도

# 2주차 (2023.03.09)

깃 허브 계정을 만들고  23-React1라는 이름의 repository를 추가했다.

깃 허브는 다수가 동시에 사용할 수 있는 사이트이다.

깃 허브 주소를 복사하고 공유하는 사이트에 올렸다.

웹 기본 연결 브라우저를 인터넷 익스플로어에서 크롬으로 변경했다.

깃 이그노어는 깃 허브의 공유과정에서 생기는 문제를 방지해주기 위한 파일이다.


# 1주차 (2023.03.02)
> 오리엔테이션
> github 가입
